#!/bin/bash

logger Fetching config $(date)

until test "$mac"
do
	. "/etc/webc/webc.conf"
done

logger "Fetching $config_url"
if curl -f -o /etc/webc/cmdline.tmp --retry 5 "$config_url"
then
	# curl has a bug where it doesn't write an empty file
	touch /etc/webc/cmdline.tmp
	# This file can be empty in the case of an invalidated configuration
	mv /etc/webc/cmdline.tmp "$config_runtime"
	logger "CONFIG: Download applied $(md5sum $config_runtime)"
else
	logger "CONFIG: Failed to download from $config_url"
fi

. "$config_runtime"


for x in $(cmdline)
do
	case $x in

		xkb=*)
			koptions=$( cmdline_get xkb )
			if setxkbmap $koptions; then logger "setxkbmap OK $koptions"; else logger "setxkbmap ERR $koptions"; fi
			;;

		# swarp=0,0 // move mouse pointer to top left of screen
		swarp=*)
			koptions=$( cmdline_get swarp )
			swarp $(echo $koptions | sed 's/[^0-9]/ /g')
			;;

		# http://webconverger.org/touch_screen_calibration/
		xinput=*)
			option=$( cmdline_get xinput )
			if eval xinput "$option"
			then
				logger "OK: xinput $option"
			else
				logger "ERROR: xinput $option"
			fi
			;;

		# https://groups.google.com/forum/#!msg/webc-users/GlHh_SX17BM/GojceXVSazgJ
		xrandr-all=*)
			xoptions=$( cmdline_get xrandr-all )

			logger "xrandr-all: $xoptions"

			xrandr | awk '$2 ~ /^connected$/ { print $1 }' | while read output
			do
				xrandr --output $output $xoptions
			done

			;;

		xrandr=*)

			xoptions=$( cmdline_get xrandr )

			if xrandr $xoptions
			then
				logger "xrandr OK $xoptions"
			else
				logger "xrandr ERR $xoptions"
			fi

			;;

		noblank)
			logger "noblank"
			xset s off
			xset -dpms
			;;

                timezone=*)
                        xoptions=$( cmdline_get timezone )
                        if timedatectl set-timezone "$xoptions"
                        then
                                logger "Setup timezone: $xoptions"
                        fi
                        ;;

		blank=*)
			secondstillblank=$((${x#blank=} * 60))
			if xset s $secondstillblank
			then
				logger "screen will blank after $secondstillblank seconds"
			else
				logger "ERROR: screen will not blank after $secondstillblank seconds"
			fi
			;;

	esac
done


if cmdline_has wake
then
	i=0
	IFS=$'\n'; for w in $(cmdline_get wake | tr ^ \\n)
	do
		sleep_time=0
		for t in $(echo ${w#*+} | grep -o '[0-9]*[A-Za-z]')
		do
			case $t in
				*[Ww]) sleep_time=$(( $sleep_time + ${t%[Ww]}*60*60*24*7 ));;
				*[Dd]) sleep_time=$(( $sleep_time + ${t%[Dd]}*60*60*24 ));;
				*[Hh]) sleep_time=$(( $sleep_time + ${t%[Hh]}*60*60 ));;
				*[Mm]) sleep_time=$(( $sleep_time + ${t%[Mm]}*60 ));;
				*[Ss]) sleep_time=$(( $sleep_time + ${t%[Ss]} ));;
			esac
		done
		wday=$(echo "$w" | grep -o '[0-9]\+:[0-9]\+\s')       # Eg. 10:00
		dura=$(( $(date +%s --date="$wday") + $sleep_time ))  # epoch

		wake[$i]=${w% +*}                                     # Eg. Sun 10:0
		unwake[$i]=$(date +"${w% $wday*} %H:%M" -d "@$dura")  # Eg. Mon-Fri 20:00
		logger "Wake at ${wake[$i]} till ${unwake[$i]}"
		i=$(( $i + 1 ))
	done
	unset i

	cat > /etc/systemd/system/wake.timer <<EOF
[Unit]
Description=Starts screen waking timer

[Timer]
$(echo "${wake[*]}" | sed 's/^/OnCalendar=/')
Persistent=true

[Install]
WantedBy=multi-user.target
EOF
	cat > /etc/systemd/system/unwake.timer <<EOF
[Unit]
Description=Stop screen waking timer

[Timer]
$(echo "${unwake[*]}" | sed 's/^/OnCalendar=/')
Persistent=true

[Install]
WantedBy=multi-user.target
EOF
	cat > /etc/systemd/system/wake.service <<EOF
[Unit]
Description=Wake up!
Before=sleep.target

[Service]
Environment="DISPLAY=:0"
ExecStart=$(which xset) dpms force on
EOF
	cat > /etc/systemd/system/unwake.service <<EOF
[Unit]
Description=Wake up! Or not!

[Service]
Environment="DISPLAY=:0"
ExecStart=$(which xset) dpms force off
EOF

# TODO: not sure if this is required
#	if cmdline_has noblank
#	then
#		echo "ExecStart=$(which xset) s off"
#		echo "ExecStartPost=$(which xset) -dpms"
#	else
#		echo "ExecStart=$(which xset) s ${secondstillblank:-10}"
#	fi >> /etc/systemd/system/wake.service

	systemctl daemon-reload
	systemctl start unwake.timer
	systemctl start wake.timer
else
	systemctl stop unwake.timer
	systemctl stop wake.timer
fi


if cmdline_has debug
then
	sshkey=$(cmdline_get ssh)
	if test "$sshkey"
	then
		mkdir ~/.ssh || true
		curl $sshkey > ~/.ssh/authorized_keys
		logger "Setup key from $sshkey"
	fi
fi


if cmdline_has shell
then
	shell=$(cmdline_get shell)
	if test "$shell"
	then
		tmp=$(mktemp)
		curl $shell > $tmp
		read -r csum _ < <(sha1sum $tmp)
		log=/var/log/$csum
		if ! test -f $log
		then
			git status &>> $log
			bash $tmp &>> $log
			echo RETURN CODE: $? &>> $log
			git status &>> $log
			logger "Ran script from $shell and logged it at $log"
		else
			logger "ALREADY ran script from $shell and logged it at $log"
		fi
	fi
fi


wpassid=$( cmdline_get wpa-ssid )
wpapsk=$( cmdline_get wpa-psk )
if test "$wpassid" && test "$wpapsk"
then
logger "Setting up wifi with $wpassid:$wpapsk"
cat <<EOF > /etc/wpa_supplicant/wpa_supplicant-wlan0.conf
ctrl_interface=/run/wpa_supplicant
network={
    ssid="$wpassid"
    psk="$wpapsk"
}
EOF
fi
